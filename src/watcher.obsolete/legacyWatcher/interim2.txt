
How the Interim2 algorithm works:

$Id: interim2.txt,v 1.4 2007/05/18 15:24:00 dkindred Exp $

Draft as of 2005.6.22.  This is probably out of date.

Nodes send HELLO packets regularly.  (every 2 seconds, for no good reason.)
Nodes then receive all the HELLO packets they hear, and maintain a list of
neighbors.  Their list of neighbors is then transmitted in the next HELLO
packet, so the nodes know which of their neighbors are symmetric.  (IE:
OLSR style HELLOs.)  A node will keep track of /all/ HELLO packets which
it hears, even if it doesn't quite care.  Thus a node which gets elected
coordinator will not be starting out with zero information.

When a node is elected coordinator, it increases its TTL, so its HELLO
packets travel further, and will get to the other coordinators (and
any possible children).

HELLO packets have a sequence number, thus a node knows when it has 
seen a specific HELLO packet (and can ignore older packets which got
repeated).  Nodes repeat HELLO packets which they have not seen before,
and whose hop count is less than their TTL.  (A possible optimization
would be to have only level 1 coordinators repeat HELLOs, which would
reduce the repeat traffic like the MPRs do in OLSR.)  When a node
repeats a HELLO packet, it puts its address into a list in the HELLO
packet.  Thus when a HELLO packet arrives, it contains the route it
took (like AODV route query packets).  Those routes are currently
only used for root packets (described later) but may also be used for
delivering reports eventually.

If a distant node with a high TTL is heard, it will be on the neighbor
list as asymmetric.  If the distant node is more hops away than the 
receiving node's TTL, then it can never be symmetric (unless the TTL
changes).  Thus to save space in the HELLO packets, nodes which are
further away than the TTL are not listed.

The asymmetric TTL is actually part of a bigger problem variously
called "the needy node" and "the TTL management thing".  How do we
deal with a topology which has a dense group of coordinators in 
one area, and a single remote coordinator in another, trying to be
a neighbor of one of the coordinators in the dense area?  The nodes
in the dense area, since they have neighbors, will not increase
their TTLs to enable the single distant coordinator to be a neighbor.

A level 0 node uses a TTL of 1.  A level n node starts with its level
n-1 TTL multiplied by 2.  So a level 1 node starts with a TTL of 2.
If it has no level 1 neighbors (IE: it can not find a desirable
coordinator) it multiplies its TTL by 2, and keeps looking.  If it
finds a desirable coordinator, it either uses it, or desires no node,
and hopes that it gets desired in turn.  

A node's TTL is reduced when it reduces its level.  A level n node
saves its level 1 to n TTLs, and just goes back to its old level n-1
TTL.  The TTL may be completely reset by dropping all the way to level
0, where TTL is always 1.

Nodes have a "select time", which is an absolute time at which they will
select a coordinator.  The select time may either be some time in the 
future, which means the node is awaiting more neighbors, some time in 
the past, which indicates that the node has decided it knows enough
neighbors to select a coordinator but there are no acceptable coordinators,
or 0 indicating the node is not looking for a coordinator (IE: it has
one).

When a node successfully chooses a coordinator, it sets its select time
to 0.  If it loses its coordinator, then the select time is set to some
time in the future, and the node "looks" for a new coordinator.  If a
node is looking for a coordinator, and a new neighbor arrives, the select 
time is set into the future again (under the assumption that neighbors
will arrive in clumps).  Thus a series of new neighbors will delay the
selection of a coordinator, until after the last neighbor arrives.

There are three ways for a node to lose its coordinator:  The coordinator
may fall off the node's neighbor list, due to partitioning of the MANET.
The coordinator may become too far away (level 0 nodes must have their
coordinator 1 hop away, level 1 and higher don't care).  Or the coordinator
may declare itself no longer a coordinator.

A node may be banned from coordinator-hood.  That information is delivered
to the node via some unspecified mechanism, and it passed to the clustering
algorithm via the idsCommunications API.  A node will simply never desire
a node which has been banned from coordinator-hood.  IE: a banned node
is banned by all the other nodes, as opposed to removing itself from 
consideration.

A node becomes a coordinator by being elected by other nodes.  The election
is done using another field in the HELLO packet, the desired coordinator
field.  The desired coordinator is reevaluated on every HELLO packet
transmission.  (not just at the select time)  So what happens when
the algorithm starts is that all the nodes are at level 0, and have
no neighbors.  Then HELLO packets are exchanged, and the nodes have
neighbors.  The nodes can not choose a coordinator at that time because
a coordinator must be of greater level than a node's level.  BUT, a
desired coordinator can be at the same or greater level.  So the nodes
announce their desired coordinators.  The desired coordinators then
realize they are desired and set their level to the greatest level of
their (would-be?) children (nodes desiring them?) + 1.  The new level is 
announced in the next HELLO), and then the level 0 nodes can choose a 
level 1 coordinator, and the level 1 nodes start looking for level 2 nodes.

A node becomes root when, as it does the expanding TTL search for
peer nodes, its TTL hits maxTTL (which may be configured) and it has
no desirable coordinator.  It then sets the root flag in its next
HELLO packet, and that is how nodes know how far away from the root
node they are located.  A node may also be assigned to be root.
When a node is assigned to be root, it immediately sets its TTL to
maxTTL, and sets its level to the greatest level of all its children
+ 1.  An assigned root also sets an assigned root flag.  That allows
multiple assigned root nodes to elect a single root from among
themselves.  The nodes that lose the election then run the normal
selection algorithm, instead of the assigned root version.

A node ceases to be a coordinator when it is no longer desired.
A node's children will not choose another coordinator just because 
a better node came into the neighborhood.  They will indicate their
preference by desiring the better node in their HELLO packets though.
The current coordinator will then set its level to the greatest level
of the nodes which desire it plus 1, and if there are no nodes which
desire it, then its level will be 0.  As soon as that new level is
announced in the next HELLO packet, all the former coordinator's 
children will act as if they had lost their coordinator, and select
a new one (IE: the new desired one).

A node ceases to be root when it finds a coordinator it desires.  When
that happens, it drops its root-ness, and sends its new coordinator a
root packet (using the route recorded in the HELLO packets).  That
root packet means that if the the root's new coordinator has no
coordinator, it is now root.  [What happens if the receiving node
*does* have a parent?  Does it forward the "root packet" up? -dk]  This
handles the case where a partitioned MANET becomes unpartitioned, the
hierarchy in one of the partitions will attach itself to the hierarchy
in the other one as soon as the roots exchange HELLO packets.

A node actually selects its coordinator and desired coordinator by making
a list of all the neighbors which could be a coordinator or desired
coordinator, and then qsorting them, using a comparison function.  That
makes redundancy straight forward: select the top n, instead of just
the top of the list.  The comparison function is that a node with
the greatest number of neighbors is the most desirable.  But if two
nodes have the same number of neighbors, then the node which is 
closest to the root node is more desirable.  If that ties, or is
unavailable, then the node with the least id is most desirable.  

The comparison function is extremely easy to modify without touching
the actual implementation.  One of to-be-tried experiments is to make
the algorithm greatest degree until a root node is selected, and
then when that information becomes available change to closest-to-root.

Another detail: "being a coordinator" really means having a level
greater than 0.  There is not an actual coordinator flag.  Becoming
a coordinator means increasing the level.

A node's coordinator is the "best" neighbor whose level is greater than
the node's level.  A node's desired coordinator is the "best" neighbor 
whose level is equal or greater.  And a node's degree is how many 
symmetric neighbors it has at any level.
