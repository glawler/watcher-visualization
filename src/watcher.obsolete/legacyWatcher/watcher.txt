
$Id: watcher.txt,v 1.2 2007/04/02 14:50:27 dkindred Exp $

Some details on the watcher

The watcher is an extremely confused program.  Its not sure what it is.  It
uses the clustering algorithm data fields, so its sortof a clustering algorithm.
It implements enough of simulator land to successfully link, so its sortof a
simulator too.  It makes idsCommunications calls, so its also a client.  It
still has the SGI copyright statements from when it was a GL demo, which is
why some of the code uses 4 spaces instead of 8 wide tabs.

The real problem is that it was implemented very abruptly, to fill a critical 
need.  I've been wanting to reimplement it for a while now [[what would you
do differently? -dk]].

Anyway, What it does is it connects to every demon on a manet as a client.
It then uses the normal idsCommunications callbacks to create a manet structure,
as if it was a simulator, of the nodes on the manet.  The biggest difference is
that the linklayer graph, which in the simulator is the base truth, is what the
clustering algorithm detects as neighbors.

It then calls simulator graphics code [[what is "simulator graphics code"?
is this something we can/do use outside of watcher? -dk]], to display the 
manet data structure,
and runs some of the metrics simulator modules to measure simulator metrics
(like the distribution of the degree of each node, etc.).  It unfortunately
duplicates some of the user interface code from the simulator, so its not
as clean as just calling the simulator graphics code.  (This is one of the
biggest problems I've been wanting to fix for some time.)

Then there are goodwin files...

goodwin files contain a timestamped log of exactly what went over the TCP
session between a demon and a client.  They even use the same marshaling 
functions.  So, the watcher can read from a goodwin file instead of connecting
to the demons on the manet.  The goodwin playback is exactly the same as
when talking to a demon, with the exception that instead of calling readReady,
one calls communicationsLogStep(), which has an argument for how much time
to read forward.
