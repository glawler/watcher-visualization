
$Id: packetapi.txt,v 1.4 2007/04/23 18:51:07 dkindred Exp $

How the packetapi module works:

The packetapi module listens on a port for incoming TCP messages from clients.
The clients then send messages to be transmitted to the packetapi module,
which encapsulates them as needed, and sends them through the simulatorland
domain.  On the far side, a receiving packetapi module will get those
simulatorland messages (possibly by way of other modules, like data and flood),
and sends them to clients via another TCP socket.

At the same time, the packetapi module observes things like arriving and
departing messages and hierarchy and sends additional messages informing the
clients of those events.

Last but not least, incoming and outgoing messages go through a mechanism not
unlike FreeBSD's ipfw, or Linux's iptables.  The clients are ordered (using
information the clients supply when they connect) into two lists, the incoming
and outgoing chains (there is a separate set for each message type).  When a
message is received, the packetapi module goes down the incoming chain of
clients, and either gives the client a copy of the message, or passes the message
to the client to be rewritten or deleted.  Thus, a client may rewrite or
delete an incoming message and all the clients after it see the modified 
message (or nothing, if it was deleted).  [[mention which API calls a client
uses to specify which chain it's listening on, what the ordering is, and
whether it wants to be able to rewrite/delete?  -dk]]

When a message is transmitted, the same thing is done, all the clients which
has indicated they are interested are given a copy, or the chance to
rewrite/remove the outgoing message.  If the message makes it to the bottom
of the outgoing chain without being deleted, the possibly modified
message is transmitted.  

Details:

Clients link to the idsCommunications library.  It contains the officially 
exported calls, and the private code found in apisupport.[ch].  The packetapi
module links into the livenetwork or simulator binary, and also includes
apisupport.[ch].

The messages on the TCP socket are in the form of ApiCommand structs, which are
defined in apisupport.h.  The ApiCommand struct has a type and a payload.  For
each type there is a marshal/unmarshal function.

So lets say a client wants to subscribe to a message type.  They call 
communicationsNameHandlerSet().  Which will create a client-space data structure
containing the message type, and a pointer to the function.  It will then 
call messageHandlerRequestMarshal() [[what calls it?  the client?  communicationsNameHandlerSet? -dk]], which returns an ApiCommand, write that
to the TCP socket, and return.

Then, a message comes in...
It is first unmarshaled into a MessageInfo struct.  
The MessageInfo struct then traverses the incoming message chain.  The message
chain code is the largest block of code in the module...  see chains.fig,
and a really nasty hand-drawn diagram of the data structure in my notepad
(I have attempted to scan it, but the copier was userfriendly).
