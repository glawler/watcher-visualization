\documentclass{article}

\pdfpagewidth 8.5in
\pdfpageheight 11in

% \setlength\topmargin{0in}
% \setlength\headheight{0in}
% \setlength\headsep{0in}
% \setlength\textheight{7.7in}
\setlength\textwidth{6.5in}
\setlength\oddsidemargin{0in}
\setlength\evensidemargin{0in}
% \setlength\parindent{0.25in}
% \setlength\parskip{0.25in} 

\usepackage{makeidx}
\makeindex
\usepackage[dvips]{graphicx}

\usepackage{url}

\pagestyle{headings}

\author{Geoff Lawler \url{<geoff.lawler@cobham.com>} \and {Michael Elkins \url{<michael.elkins@cobham.com>}}}

\title{Watcher User's Guide}

\begin{document}
\maketitle
\newpage 

\tableofcontents
\newpage

\section{Introduction}

The {\it watcher}, or {\it watcher system} allows users to visualize emulated Mobile As-Hoc Networks. 

\section{General Watcher Information}
\subsection{Watcher Architecture and Communications}

Figure \ref{fig:watcherArch} shows the three main components in the watcher system: test node daemons (or ``feeders''), a watcher
daemon, and a number of graphical user interfaces (or ``GUIs''). The basic operation is this: the test nodes feed state 
information to a running instance of the watcher daemon, {\it watcherd}. The watcher daemon saves all the state information
locally to a database. A GUI connects to a running watcher daemon and requests a stream of state information, then displays it
using some (most likely) graphical mechanism. The daemon acts as a message cache and demulitplexer, streaming multiple
message streams from multiple test nodes into a single stream of messages. 

The interface between the watcher daemon and the test node is a simple message interface. The test node daemon connects
to a daemon, sends one or more messages, then disconnects. Some messages contain abstract state information about that test node
such as current set of neighbors, current location, etc. Other messages contain lower-level graphical display commands like ``change
color'' or ``draw an egde between these two nodes''.  For a list of all supported message, see the {\it watcher::event::Message} class 
documentation in the watcher developer documention. 

The interface between the GUI(s) and the watcher daemon is also message based, but also includes the concept of a message
stream. The stream is composed of messages and has an interface that manipulates the stream content, time, direction, and rate. A message
stream can start at any time {\it t} for which there is data. The stream rate can be set as a multipler of real time. For instance
a GUI can request that the stream go 10x the speed at which the messages were received. (This only will work od course if there is 
a cache of messages that can be sent at 10x - once the message cache is exhausted, the stream is sent at the rate the messages
are recieved, 1x real time.) 

There are three modes the system can be run in, ``record mode,'' ``live mode,'' and ``playback mode''. In ``record'' mode, These modes
can be moved into and out of in real time depending on the needs of the user. In record mode, the test nodes and a watcher daemon are
run. The test nodes send state data to the daemon, the the daemon writes those messages to a local database. In live mode, the test 
nodes are feeding data to the daemon (which writes the information to a database) and some number of GUIs connect to the 
daemon and request a message stream. Note that the GUIs can request messages from the start of the test run - thay are not
contrained to ``live'' messages; live mode simply means that there are, at that moment, new messages arriving at the daemon
and being recorded. The last mode os playback mode and does not involve test node daemons. In this mode, the watcher daemon
is started with an existing database full of messages and it just waits for connections from a GUI. When a GUI connects, the 
watcher daemon streams it the requested messages, this ``playing back'' a ``recorded'' test run. 

\begin{figure}[here]
\label{fig:watcherArch}
\centering
\includegraphics[width=0.8\textwidth]{watcherArch.eps}
\caption{The basic architecture of the watcher system.}
\end{figure}

\subsection{Obtaining and Building Watcher}
Mention GPL'd-ness of the watcher. Give reference to repo location. 

Give list of dependencies.

Give simple build instructions: ./autogen.sh, ./configure, make, sudo make install, cd clients/legacyWatcher, make, make install \ldots.

\subsection{Log Property Files}
Give general intro with examples of the standard format and workings of the log.properties file. (Just like Java if peeps know that.)

\subsection{Configuration (cfg) Files} 
explain layout of standard config files and arguments that most (all?) watcher modules understand (-f cfg). 

\subsection{Command Line Arguments}
Most binaries take a {\tt -c} (or {\tt -f}) arugment which gives the location of the {\tt cfg} file. Mention this. Also note that most binaries 
just take that option and nothing else. 

\section{Test Node Components}
\subsection{Watcher API}
Mention watcher messages and give types. Mention something else that's interesting and useful. 

\subsection{Scripting Interface}
For each watcher message there is a command line binary to send that message. These binaries can be used directly in shell scripts or invoked via a system call from most scripting languages to send 
an instance of that message to a running watcher daemon instance. Each binary allows the user to specify the content of the message and the daemon instance to send the message to. 

In many cases, the node that the message ``comes from'' can be set as well. This allows a user on any machine that can connect to a watcher daemon, the ability to modify nodes, edges, lables, etc of any 
test node. This is useful for debugging or real time modification of an aspect of the test bed. For instance a single machine could monitor traffic rates between nodes and update 
the edges between those nodes with the current traffic rate. 
\\\\
The available commands are:
\begin{itemize}
\item sendColorMessage (page \pageref{sendColorMessage})
\item sendEdgeMessage (page \pageref{sendEdgeMessage})
\item sendGPSMessage (page \pageref{sendGPSMessage})
\item sendConnectivityMessage (page \pageref{sendConnectivityMessage})
\item sendDataPointMessage (page \pageref{sendDataPointMessage})
\item sendLabelMessage (page \pageref{sendLabelMessage})
\item showClock (page \pageref{showClock})
\end{itemize}
The following pages give details for each command.
\include{sendColorMessage}
\include{sendEdgeMessage}
\include{sendGPSMessage}
\include{sendConnectivityMessage}
\include{sendDataPointMessage}
\include{sendLabelMessage}
\include{showClock}

\subsection{Test Node Daemons}
These daemons are run on the test nodes and feed information about the test nodes to the watcher daemon. This information is then streamed to GUI(s) attached to the daemon, which display it.
\input{gpsFeeder}
\input{watcherHierarchyClient}

\input{watcherd}

\section{Watcher GUIs}

Talk about GUIs here. Legacy watcher is OpenGL, others are engine based and just barely started proof of concept.

\subsection{Legacy Watcher}
\label{LegacyWatcher}
\begin{figure}[here]
\label{fig:LegacyWatcherClock}
\centering
\includegraphics[width=0.8\textwidth]{legWatcherGUI.eps}
\caption{The legacy watcher showing a running instance of showClock.}
\end{figure}

\subsection{ogreWatcher}
\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{ogreWatcherGUI.eps}
\caption{The ogreWatcher showing a running instance of showClock.}
\end{figure}

Built with OGRE.
\subsection{Watcher3d}
Built with Delta-3d.

\printindex

\end{document}
