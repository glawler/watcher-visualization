Installed QT4:
    yum install qt4.i386 qt4-x11.i386 PyQt4.i386 PyQt4-devel.i386 qt4-devel.i386 qt4-sqlite.i386 qt4-doc.i386
    49M download on current glory Fedora 8 image.

Installed Boost Libraries:
    1. yum install boost-doc.i386 boost-devel.i386 boost-devel-static.i386 boost.i386
    2. Discovered that the asio library for network development is in boost version 1.36 and Fedora 8
    only installs boost version1.34, so I uninstalled boost:
        yum erase boost-doc.i386 boost-devel.i386 boost-devel-static.i386 boost.i386
    and pulled down the source (boost_1_36_0.tar.bz2) from boost.org, then
        tar jxvf boost_1_36_0.tar.bz2
        cd boost_1_36_0
        ./configure
        make 
        sudo make install

Ran throught the 14 step QT Tutorial, which builds a simple cannon game.

Thought about network clients/server implemenation:
1. Server runs 'panopticond', a daemon which listens for connections from clients. 
    A. Accepts timestamped messages (events) from clients.
    B. Feeds demulitplexed message stream to GUI that connects to it.
    C. Supports time-based message queries:
        I. 'Send current stream' - 'now' according to server, forward in time at 1x speed.
        II. 'Send stream starting at time t'
            a. Send stream in reverse or forward.
            b. Send stream at different speeds (1/2x, 1x, 2x, fast as possible, etc)
    D. Saving/Reading messages.
        I. Support for saving message stream.
        II. Support for reading saved message streams.
        III. Use a database for message storage/retrival? 
            a. May be nice for 2ndary tools.
            b. Will help with speed of retrival/playback?
            c. Will help with post-run analysis?
            d. Will get correct time-oriented message ordering for free? (i.e.
                insert all messages, then query SORTed by time for sending
                to clients. Is this fast or not?)
    F. "Messages" above are messages sent directly from clients. Should there be support
        for knowledge specific messages, e.g. network-topology-at-time-t-is messages? These
        messages would use knowledge of what the messages contain to answer specific 
        questions based on the stream of all messages from all clients. (although I can't
        think of an example other than topology).
            a. This would mean there would be messsage above and beyond client messages
            sent from panopticond
            b. Would need to add an analysis module to the server
                i. would cease being a straight messages demultiplexer and 
                become demulitplexer/analysis. Do we want
                this functionality here or somewhere else?
            c. An advantage is that many messages can be compressed into a single message using 
            knowledge of what the messsages contain. i.e. send 1 topolgy message instead of 
            N node-is-connected-to-these-nodes messages. 
2. Clients run a watcherd which listens for connections from localhost and has a message-sending API
    A. Support for current Hierarchy/Watcher message API (draw label, draw line, etc)
    B. Simple message send API
        I. Support for python interface.
        II. Support for other scripting interface, perl, bash, etc.
3. GUI connects to panopticond deamon and requests message streams.
4. Everything is sockets-based connection-location agnostic, if possible.
5. Support for compressed (gzipped) messages on the wire.
            TCP                 TCP             UDP
    GUI    <----> panopticond  <--->  watcherd <---> client1, client2, client3
    [GUI]  <---->              <--->  watcherd <---> client1, client2, client3
    [...]  ...                 <--->  ...
    [GUI]  <--->               <--->  watcherd <---> client1, client2, client3

Network programming questions:
1. What to write it in?
    A. Use ACE?
        I. Heavyweight
        II. Must install as download/configure/make
    B Use Boost?
        I. Somewhat standard for C++ - 10 libs from boost are being added to the STL
        II. Network interface based on ASIO
        III. Takes some pattern ideas from ACE
        IV. Easy install on Fedora - 'yum install boost.i368 ...'
            a. Fedora 8 Boost library does not include ASIO library - the networking library. So a 
            download/compile installation of Boost may be needed anyway. Although the boost
            people do support a static build configuration, so statically linked binaries
            can be given, keeping the messiness to just build machines.
        V. Support for ssl sockets?
        VI. Is there support for compressed packets?
    C. Straight select()/poll() Steven's style UNIX network programming?
    D. Leaning towards boost. (May use boost for graph reprsentation of
        network topology as well). 

Crammed the 'legacy watcher' into a QTGLWidget instance.
1. Added menus, etc.
2. The hierarchy view is still borked.

Created new repository on src: /project/watcher/hg/watcher and cloned current source there. 

Checked out Horde3D graphics engine. I was led to it as it is very easy to create a Horde3D window
as an QTWidget. Spent Sunday morning playing around with that - embedded the "Chicago" sample into 
a Qt widget and displayed it. Needed to add an animating timer and the FPS was removed. Other than
that, it was pretty straight forward. 

Wrote basic description of network infrastructure in email to Dan, Darrell, and Michael for 
feedback.

Installed libconfig into top level dir. libconfig is a C and C++ library for reading and 
writing configuration files. This will replace all the commandline and config file stuff. 

Installed lib4cpp for logging. We'll see if we actually use it as we had some troubles
with it when we used it a few years ago. It's at 1.0 now, so maybe things are better.

Wasted a whole day looking into the boost::serialize library for serializing messages
on the wire. It likes to do everything as strings (or, grr, XML), so it's not very good
for compat messages. Which is annoying. 

Removed log4cpp after I couldn't find any useful documention on it. 
Installed Apache's log4cxx - which appaers to be excellent.

Got basic server and client classes up and running. There is now a message class which is 
easily serializable and can be sent across the network. The server connection and client  
connection classes understand this format and can transfer it. 

log4cxx segfaults sometimes, so I had to wrap the calls to it in a try/catch block. Which 
is annoying. 

Installed qwt.5.1.1 - a QT widget set for doing 2D graphs. - Will use for showing node driven stats
like CPU usage and bandwidth utilization.


---- INSTALLING on COKE 10/09/08 -----------
These should be the same steps needed to install on any Fedora 8 machine.

1) Install QT 4:
    > sudo yum install qt4.i386 qt4-x11.i386 PyQt4.i386 PyQt4-devel.i386 qt4-devel.i386 qt4-sqlite.i386 qt4-doc.i386
2) INstall boost libraries
    ****DO NOT DO STEP 2 IF ONLY BUILING THE new old watcher GUI******
    (Version greater than 1.36 is needed for new watcher network infrastructure - not for new old watcher GUI - but might
    as well install the "correct" version anyway.)
    > yum update boost.i386
    Check the version that would be installed, if less than 1.36 do the following:
    - Download the latest version of boost greater than or equal to 1.36 from
    http://www.boost.org/users/download/
    Then: 
    > cd src
    > tar jxvf ~/Desktop/boost_1_36_0.tar.bz2 # or whatever version you have
    > cd boost_1_36_0
    > ./configure
    > make 
    > sudo make install
3) Build and install libconfig into local directory
    Libconfig is a library used to parse and write configuration files. Only lightly used int he new old watcher, 
    but used none the less.
    > cd src
    > tar zxvf ../tars/libconfig-1.3.1.tar.gz 
    > cd libconfig-1.3.1/
    > ./configure --prefix=$HOME/src/watche
    > make 
    (if you have a multiprocessor machine use -j4 or -j8 to speed compliation.)
    > make install      # don't need to be root, as you're installing in local directory.
4) Install log4cxx - the logging library used by the watcher and all components. 
    


